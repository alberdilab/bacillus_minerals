[["index.html", "AlberdiLab | Carbajo et al. 2026 Study in progress Chapter 1 Introduction 1.1 Prepare the R environment", " AlberdiLab | Carbajo et al. 2026 Study in progress Carlota Carbajo, Nanna Gaun, Antton Alberdi1, Karina Sand Last update: 2026-02-01 Chapter 1 Introduction This webbook contains all the code used for data analysis in study of gut microbiomes of newts across ponds included in a restoration plan. 1.1 Prepare the R environment 1.1.1 Environment To reproduce all the analyses locally, clone this repository in your computer using: RStudio &gt; New Project &gt; Version Control &gt; Git And indicating the following git repository: https://github.com/alberdilab/bacillus_minerals.git Once the R project has been created, follow the instructions and code chunks shown in this webbook. 1.1.2 Libraries Install this packages if needed ## Bioconductor packages #https://cran.r-project.org/web/packages/BiocManager/vignettes/BiocManager.html if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) requiredPackages = c(&#39;edgeR&#39;,&#39;DESeq2&#39;,&#39;vsn&#39;,&#39;org.Hs.eg.db&#39;, &quot;knitr&quot;) for (p in requiredPackages) { if(p %in% rownames(installed.packages()) == FALSE) {BiocManager::install(p)} } ## CRAN packages requiredPackages = c(&#39;ggplot2&#39;,&#39;dplyr&#39;,&#39;NMF&#39;,&#39;grDevices&#39;, &quot;hexbin&quot;, &quot;statmod&quot;, &quot;reshape2&quot;) for (p in requiredPackages) { if(p %in% rownames(installed.packages()) == FALSE) {install.packages(p)} } The following R packages are required for the data analysis. # Base library(R.utils) library(knitr) library(tidyverse) library(devtools) library(tinytable) library(rairtable) library(janitor) library(broom) library(ggtext) library(tibble) library(stringr) library(dplyr) library(DESeq2) library(edgeR) library(ggplot2) library(vsn) library(NMF) library(org.Hs.eg.db) library(grDevices) library(hexbin) library(statmod) library(reshape2) library(pheatmap) University of Copenhagen, antton.alberdi@sund.ku.dk↩︎ "],["prepare-data.html", "Chapter 2 Prepare data 2.1 Bioinformatics 2.2 Load data 2.3 Prepare data", " Chapter 2 Prepare data 2.1 Bioinformatics 2.1.1 Get data mkdir genome wget -P genome https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/009/045/GCF_000009045.1_ASM904v1/GCF_000009045.1_ASM904v1_genomic.fna.gz mkdir reads # fetch data from ERDA 2.1.2 Run annotation and profiling drakkar annotating -b genome drakkar expressing -b genome -r reads 2.1.3 Experimental design This project consists of 40 RNAseq samples. Twenty samples were collected at 3 h and the remaining 20 at 24 h. The experiment includes one control group (C) and three treatment groups, in which bacteria were exposed to 5 mg/mL of the following minerals: goethite (G), hematite (H) and mica (M). Each condition includes 4 biological replicates for which RNA was extracted using the ZymoBIOMICS RNA Kit, and one replicate for which RNA was extracted using the DREX protocol. Experimental design 2.1.4 Get working files gene_annotations.tsv.xz gene_counts.tsv.xz 2.2 Load data Samples have been split in different lanes during sequencing so gene_counts.tsv.xz has more columns that what is expected for the conditions of the experiments (40 different samples). read_counts &lt;- read_tsv( &quot;data/gene_counts.tsv.xz&quot;, comment = &quot;#&quot;, # skip featureCounts metadata col_names = TRUE, # header is present show_col_types = FALSE # silence messages ) %&gt;% dplyr::rename(gene = Geneid) %&gt;% pivot_longer(!c(gene,Chr,Start,End,Strand,Length),names_to=&quot;library&quot;,values_to = &quot;counts&quot;) %&gt;% mutate(sample = str_extract(library, &quot;^[^_]+&quot;)) %&gt;% group_by(gene,Chr,Start,End,Strand,Length,sample) %&gt;% summarise(counts=sum(counts)) %&gt;% pivot_wider(c(gene,Chr,Start,End,Strand,Length), names_from = &quot;sample&quot;, values_from = &quot;counts&quot;) gene_annotations &lt;- read_tsv(&quot;data/gene_annotations.tsv.xz&quot;) %&gt;% dplyr::rename(gene=1) sample_metadata &lt;- read_csv(&quot;data/sample_metadata.csv&quot;) sample_metadata &lt;- sample_metadata %&gt;% mutate(timepoint = str_extract(`Sample ID`, &quot;\\\\d+$&quot;), mineral_code = substr(`Sample ID`, 3, 3)) 2.3 Prepare data Preliminary processing of the data to prepare it for visualizations read_counts &lt;- read_counts %&gt;% pivot_longer(!c(gene,Chr,Start,End,Strand,Length),names_to=&quot;sample&quot;,values_to = &quot;counts&quot;) %&gt;% inner_join(sample_metadata, by=&quot;sample&quot;) %&gt;% mutate(ID = paste(`Sample ID`, str_sub(Extraction, 1, 1), sep = &quot;_&quot;)) %&gt;% dplyr::select(gene, ID, counts) %&gt;% pivot_wider(c(gene), names_from = &quot;ID&quot;, values_from = &quot;counts&quot;) %&gt;% column_to_rownames(var = &quot;gene&quot;) sample_metadata &lt;- sample_metadata %&gt;% mutate(ID = paste(`Sample ID`, str_sub(Extraction, 1, 1), sep = &quot;_&quot;)) %&gt;% column_to_rownames(var = &quot;ID&quot;) "],["preliminary-visualizations.html", "Chapter 3 Preliminary visualizations 3.1 Filtering and normalization 3.2 Preliminary visualizations 3.3 Preliminary visualizations wo DREX group", " Chapter 3 Preliminary visualizations 3.1 Filtering and normalization # Create edgeR DGEList dge &lt;- DGEList(counts = read_counts) # Filter lowly expressed genes (keep genes with CPM&gt;1 in at least 2 samples) keep &lt;- rowSums(cpm(dge) &gt; 1) &gt;= 2 dge &lt;- dge[keep, , keep.lib.sizes = FALSE] # Normalize for library size (TMM normalization) dge &lt;- calcNormFactors(dge) # Log2 CPM transformation logCPM &lt;- cpm(dge, log = TRUE, prior.count = 1) # log2(CPM + 1) 3.2 Preliminary visualizations 3.2.1 Library size plot In this plot we see a fold difference of 3-4X between the samples with the lowest number of reads and the samples with the highest number of reads. Most of the difference is between the 3 h samples (higher expression, exponential growth curve) and 24 h samples (lower expression, stationary phase). At 24 h DREX protocol seems yield more RNA than most of Zymo samples. Goethite samples at 3 h -(except DREX sample) have less reads than the rest of 3 h samples, which agrees with the concentrations calculated with Qubit. We expect some cell death in goethite at 3 h. # Total reads per sample (wihtout filtering and normalizing) lib_sizes &lt;- colSums(read_counts) par(mgp = c(3.4, 1, 0)) barplot(lib_sizes, las = 2, cex.axis = 0.7, ylab = &quot;Total reads&quot;, main = &quot;Library sizes per sample&quot;) 3.2.2 Box plots of transformed counts Most of the samples processed with DREX protocol show narrower distributions (reads are more evenly distributed across genes), is this good or bad? boxplot(logCPM, las = 2, outline = FALSE, ylab = &quot;log2 CPM&quot;, main = &quot;Distribution of log2-CPM per sample&quot;) 3.2.3 Hierarchical clustering The clustering separates each mineral sample quite good at 3 h, but not that good at 24 h (except for goethite) distance_mat &lt;- as.dist(1 - cor(logCPM)) # Pearson correlation distance hclust_res &lt;- hclust(distance_mat) plot(hclust_res, labels = colnames(logCPM), main = &quot;Hierarchical Clustering (log2 CPM)&quot;) 3.2.4 Sample-sample distance heatmap Distance calculation is the same as the previous one but here with all the metadata and pairwise distances visible heatmap_metadata &lt;- sample_metadata %&gt;% dplyr::select(`Qubit conc ng/uL`, Extraction, timepoint, mineral_code) sample_dist &lt;- as.dist(1 - cor(logCPM, method = &quot;pearson&quot;)) pheatmap(as.matrix(sample_dist), annotation_col = heatmap_metadata, main = &quot;Sample–sample distance heatmap&quot;) 3.2.5 PCA In the PCA there are some interesting observations: The first PC explains most of the variance in the samples and it clearly separates the samples at 3 h and 24 h for all the minerals and RNA extraction protocols. -PC2 captures some of the variance between samples processed with DREX at 24 h. It seems for samples at 3 h the extraction protocol did not have that effect. -PC2 and especially PC3 caputres some of the variance that differentiates the goethite samples at 3 h (maybe stress response?) pca_res &lt;- prcomp(t(logCPM)) # samples as rows pca_scores &lt;- as.data.frame(pca_res$x) %&gt;% tibble::rownames_to_column(&quot;sample_pca&quot;) pca_metadata &lt;- sample_metadata %&gt;% tibble::rownames_to_column(&quot;sample_pca&quot;) pca_df &lt;- pca_scores %&gt;% dplyr::left_join(pca_metadata, by = &quot;sample_pca&quot;) # Calculate percent of variance explained # Variance explained per PC pca_var &lt;- pca_res$sdev^2 pca_var_frac &lt;- pca_var / sum(pca_var) # Percent variance explained pca_var_pct &lt;- round(100 * pca_var_frac, 1) ggplot(pca_df, aes(x = PC1, y = PC2, color = mineral_code, shape = timepoint)) + geom_point(size = 3) + geom_text(aes(label = sample_pca), vjust = -0.7, size = 3) + theme_bw() + labs( title = &quot;PCA of log2-CPM counts&quot;, x = paste0(&quot;PC1 (&quot;, pca_var_pct[1], &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, pca_var_pct[2], &quot;%)&quot;) ) ggplot(pca_df, aes(x = PC1, y = PC3, color = mineral_code, shape = timepoint)) + geom_point(size = 3) + geom_text(aes(label = sample_pca), vjust = -0.7, size = 3) + theme_bw() + labs( title = &quot;PCA of log2-CPM counts&quot;, x = paste0(&quot;PC1 (&quot;, pca_var_pct[1], &quot;%)&quot;), y = paste0(&quot;PC3 (&quot;, pca_var_pct[3], &quot;%)&quot;) ) ggplot(pca_df, aes(x = PC2, y = PC3, color = mineral_code, shape = timepoint)) + geom_point(size = 3) + geom_text(aes(label = sample_pca), vjust = -0.7, size = 3) + theme_bw() + labs( title = &quot;PCA of log2-CPM counts&quot;, x = paste0(&quot;PC2 (&quot;, pca_var_pct[2], &quot;%)&quot;), y = paste0(&quot;PC3 (&quot;, pca_var_pct[3], &quot;%)&quot;) ) pca_var_df &lt;- data.frame( PC = factor(paste0(&quot;PC&quot;, seq_along(pca_var_pct)), levels = paste0(&quot;PC&quot;, seq_along(pca_var_pct))), variance = pca_var_pct ) ggplot(pca_var_df[1:15, ], aes(x = PC, y = variance)) + geom_col(fill = &quot;steelblue&quot;) + geom_line(aes(group = 1)) + geom_point() + theme_bw() + labs( title = &quot;Variance explained by principal components&quot;, y = &quot;Variance explained (%)&quot;, x = &quot;&quot; ) pca_var_df$cumulative &lt;- cumsum(pca_var_df$variance) ggplot(pca_var_df[1:20, ], aes(x = PC, y = cumulative)) + geom_line(group = 1) + geom_point() + theme_bw() + labs( title = &quot;Cumulative variance explained&quot;, y = &quot;Cumulative variance (%)&quot;, x = &quot;&quot; ) 3.3 Preliminary visualizations wo DREX group We plot some of the same visualizations after removing the DREX samples. 3.3.1 Filtering DREX group, filtering and normalization # Filter out samples processed using DREX protocol read_counts_f &lt;- read_counts %&gt;% dplyr::select(-ends_with(&quot;D&quot;)) # Create edgeR DGEList dge &lt;- DGEList(counts = read_counts_f) # Filter lowly expressed genes (keep genes with CPM&gt;1 in at least 2 samples) keep &lt;- rowSums(cpm(dge) &gt; 1) &gt;= 2 dge &lt;- dge[keep, , keep.lib.sizes = FALSE] # Normalize for library size (TMM normalization) dge &lt;- calcNormFactors(dge) # Log2 CPM transformation logCPM &lt;- cpm(dge, log = TRUE, prior.count = 1) # log2(CPM + 1) 3.3.2 Hierarchical clustering distance_mat &lt;- as.dist(1 - cor(logCPM)) # Pearson correlation distance hclust_res &lt;- hclust(distance_mat) plot(hclust_res, labels = colnames(logCPM), main = &quot;Hierarchical Clustering (log2 CPM)&quot;) 3.3.3 Sample-sample distance heatmap heatmap_metadata &lt;- sample_metadata %&gt;% dplyr::select(`Qubit conc ng/uL`, Extraction, timepoint, mineral_code) sample_dist &lt;- as.dist(1 - cor(logCPM, method = &quot;pearson&quot;)) pheatmap(as.matrix(sample_dist), annotation_col = heatmap_metadata, main = &quot;Sample–sample distance heatmap&quot;) 3.3.4 PCA Observations after removing the DREX samples: PC1 keeps capturing the variance related to the timepoint of sample collection. PC2 clearly separates the goetihte smaples at 3 h and a little bit at 24 h, some of the expression pattern in goethite is quite different at the beginning and the difference start fading after 24 h. PC3 separates the goethite samples at 24 h but not at 3 h. PC4 separates the controls at 24 h pca_res &lt;- prcomp(t(logCPM)) # samples as rows pca_scores &lt;- as.data.frame(pca_res$x) %&gt;% tibble::rownames_to_column(&quot;sample_pca&quot;) pca_metadata &lt;- sample_metadata %&gt;% tibble::rownames_to_column(&quot;sample_pca&quot;) pca_df &lt;- pca_scores %&gt;% dplyr::left_join(pca_metadata, by = &quot;sample_pca&quot;) # Calculate percent of variance explained # Variance explained per PC pca_var &lt;- pca_res$sdev^2 pca_var_frac &lt;- pca_var / sum(pca_var) # Percent variance explained pca_var_pct &lt;- round(100 * pca_var_frac, 1) ggplot(pca_df, aes(x = PC1, y = PC2, color = mineral_code, shape = timepoint)) + geom_point(size = 3) + geom_text(aes(label = sample_pca), vjust = -0.7, size = 3) + theme_bw() + labs( title = &quot;PCA of log2-CPM counts&quot;, x = paste0(&quot;PC1 (&quot;, pca_var_pct[1], &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, pca_var_pct[2], &quot;%)&quot;) ) ggplot(pca_df, aes(x = PC1, y = PC3, color = mineral_code, shape = timepoint)) + geom_point(size = 3) + geom_text(aes(label = sample_pca), vjust = -0.7, size = 3) + theme_bw() + labs( title = &quot;PCA of log2-CPM counts&quot;, x = paste0(&quot;PC1 (&quot;, pca_var_pct[1], &quot;%)&quot;), y = paste0(&quot;PC3 (&quot;, pca_var_pct[3], &quot;%)&quot;) ) ggplot(pca_df, aes(x = PC2, y = PC3, color = mineral_code, shape = timepoint)) + geom_point(size = 3) + geom_text(aes(label = sample_pca), vjust = -0.7, size = 3) + theme_bw() + labs( title = &quot;PCA of log2-CPM counts&quot;, x = paste0(&quot;PC2 (&quot;, pca_var_pct[2], &quot;%)&quot;), y = paste0(&quot;PC3 (&quot;, pca_var_pct[3], &quot;%)&quot;) ) ggplot(pca_df, aes(x = PC3, y = PC4, color = mineral_code, shape = timepoint)) + geom_point(size = 3) + geom_text(aes(label = sample_pca), vjust = -0.7, size = 3) + theme_bw() + labs( title = &quot;PCA of log2-CPM counts&quot;, x = paste0(&quot;PC3 (&quot;, pca_var_pct[3], &quot;%)&quot;), y = paste0(&quot;PC4 (&quot;, pca_var_pct[4], &quot;%)&quot;) ) pca_var_df &lt;- data.frame( PC = factor(paste0(&quot;PC&quot;, seq_along(pca_var_pct)), levels = paste0(&quot;PC&quot;, seq_along(pca_var_pct))), variance = pca_var_pct ) ggplot(pca_var_df[1:15, ], aes(x = PC, y = variance)) + geom_col(fill = &quot;steelblue&quot;) + geom_line(aes(group = 1)) + geom_point() + theme_bw() + labs( title = &quot;Variance explained by principal components&quot;, y = &quot;Variance explained (%)&quot;, x = &quot;&quot; ) pca_var_df$cumulative &lt;- cumsum(pca_var_df$variance) ggplot(pca_var_df[1:20, ], aes(x = PC, y = cumulative)) + geom_line(group = 1) + geom_point() + theme_bw() + labs( title = &quot;Cumulative variance explained&quot;, y = &quot;Cumulative variance (%)&quot;, x = &quot;&quot; ) 3.3.5 Next ideas Look at PCAs for timepoints separately (or removing goethite samples) Repeat some visualizatios using kegg and pfam groups Repeat some visualizations selecting only the most variable genes "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
